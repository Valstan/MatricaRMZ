/**
 * In-memory LRU cache for idempotency keys.
 *
 * Prevents duplicate processing when a client retries a push request
 * (e.g. due to network timeout) that was already successfully applied.
 *
 * Keys are UUIDv4 strings generated by clients, values are the cached
 * response payloads. Entries expire after TTL_MS (default 10 minutes).
 */

/** Cached response for a successfully processed push. */
export type IdempotencyCacheEntry = {
  /** Timestamp when the entry was stored. */
  storedAt: number;
  /** The original response payload to replay on duplicate requests. */
  response: unknown;
};

const DEFAULT_MAX_ENTRIES = 50_000;
const DEFAULT_TTL_MS = 10 * 60 * 1000; // 10 minutes

class IdempotencyCache {
  private readonly maxEntries: number;
  private readonly ttlMs: number;
  /** Map preserves insertion order; we use it as a poor-man's LRU. */
  private readonly store = new Map<string, IdempotencyCacheEntry>();

  constructor(maxEntries = DEFAULT_MAX_ENTRIES, ttlMs = DEFAULT_TTL_MS) {
    this.maxEntries = maxEntries;
    this.ttlMs = ttlMs;
  }

  /** Check if key exists and is not expired. Returns cached response or undefined. */
  get(key: string): unknown | undefined {
    const entry = this.store.get(key);
    if (!entry) return undefined;
    if (Date.now() - entry.storedAt > this.ttlMs) {
      this.store.delete(key);
      return undefined;
    }
    return entry.response;
  }

  /** Store a response for the given idempotency key. */
  set(key: string, response: unknown): void {
    // Evict oldest entries if at capacity
    if (this.store.size >= this.maxEntries) {
      this.evictExpired();
    }
    // If still at capacity after eviction, remove oldest entry
    if (this.store.size >= this.maxEntries) {
      const oldest = this.store.keys().next().value;
      if (oldest !== undefined) this.store.delete(oldest);
    }
    this.store.set(key, { storedAt: Date.now(), response });
  }

  /** Check if a key is currently being processed (to handle concurrent duplicate requests). */
  has(key: string): boolean {
    const entry = this.store.get(key);
    if (!entry) return false;
    if (Date.now() - entry.storedAt > this.ttlMs) {
      this.store.delete(key);
      return false;
    }
    return true;
  }

  /** Reserve a key as "in-flight" before processing begins. */
  reserve(key: string): void {
    this.store.set(key, { storedAt: Date.now(), response: null });
  }

  /** Remove expired entries. */
  private evictExpired(): void {
    const now = Date.now();
    for (const [k, v] of this.store) {
      if (now - v.storedAt > this.ttlMs) {
        this.store.delete(k);
      }
    }
  }

  /** Current cache size (for diagnostics). */
  get size(): number {
    return this.store.size;
  }
}

/** Singleton cache instance shared across the application. */
export const idempotencyCache = new IdempotencyCache();
